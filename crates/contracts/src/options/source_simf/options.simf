/*
 * POC: Options â€“ Collateral Covenant (Exercise, Cancellation, Expiry)
 * 
 * Important: Currently only the LBTC collateral is supported.
 * 
 * Room for optimization: 
 * - https://github.com/BlockstreamResearch/simplicity-contracts/issues/2
 * - (batching) https://github.com/BlockstreamResearch/simplicity-contracts/issues/4
 */

/// Assert: a == b * expected_q, via divmod
fn divmod_eq(a: u64, b: u64, expected_q: u64) {   
    let (q, r): (u64, u64) = jet::div_mod_64(a, b);
    assert!(jet::eq_64(q, expected_q));
    assert!(jet::eq_64(r, 0));
}

fn get_output_script_hash(index: u32) -> u256 {
    unwrap(jet::output_script_hash(index))
}

fn get_input_script_hash(index: u32) -> u256 {
    unwrap(jet::input_script_hash(index))
}

fn get_output_explicit_asset_amount(index: u32) -> (u256, u64) {
    let pair: (Asset1, Amount1) = unwrap(jet::output_amount(index));
    let (asset, amount): (Asset1, Amount1) = pair;
    let asset_bits: u256 = unwrap_right::<(u1, u256)>(asset);
    let amount: u64 = unwrap_right::<(u1, u256)>(amount);
    (asset_bits, amount)
}

fn get_input_explicit_asset_amount(index: u32) -> (u256, u64) {
    let pair: (Asset1, Amount1) = unwrap(jet::input_amount(index));
    let (asset, amount): (Asset1, Amount1) = pair;
    let asset_bits: u256 = unwrap_right::<(u1, u256)>(asset);
    let amount: u64 = unwrap_right::<(u1, u256)>(amount);
    (asset_bits, amount)
}

fn ensure_one_bit(bit: bool) { assert!(jet::eq_1(<bool>::into(bit), 1)); }
fn ensure_zero_bit(bit: bool) { assert!(jet::eq_1(<bool>::into(bit), 0)); }

fn increment_by(index: u32, amount: u32) -> u32 {
    let (carry, result): (bool, u32) = jet::add_32(index, amount);
    ensure_zero_bit(carry);
    result
}

fn ensure_input_and_output_script_hash_eq(index: u32) {
    assert!(jet::eq_256(unwrap(jet::input_script_hash(index)), unwrap(jet::output_script_hash(index))));
}

fn ensure_output_is_op_return(index: u32) {
    match jet::output_null_datum(index, 0) {
        Some(entry: Option<Either<(u2, u256), Either<u1, u4>>>) => (),
        None => panic!(),
    }
}

fn ensure_input_asset_eq(index: u32, expected_bits: u256) {
    let asset: Asset1 = unwrap(jet::input_asset(index));
    let asset_bits: u256 = unwrap_right::<(u1, u256)>(asset);
    assert!(jet::eq_256(asset_bits, expected_bits));
}

fn ensure_output_asset_eq(index: u32, expected_bits: u256) {
    let asset: Asset1 = unwrap(jet::output_asset(index));
    let asset_bits: u256 = unwrap_right::<(u1, u256)>(asset);
    assert!(jet::eq_256(asset_bits, expected_bits));
}

fn ensure_output_asset_with_amount_eq(index: u32, expected_bits: u256, expected_amount: u64) {
    let (asset, amount): (u256, u64) = dbg!(get_output_explicit_asset_amount(index));
    assert!(jet::eq_256(asset, expected_bits));
    assert!(jet::eq_64(amount, expected_amount));
}

fn ensure_input_script_hash_eq(index: u32, expected: u256) {
    assert!(jet::eq_256(unwrap(jet::input_script_hash(index)), expected));
}

fn ensure_output_script_hash_eq(index: u32, expected: u256) {
    assert!(jet::eq_256(unwrap(jet::output_script_hash(index)), expected));
}

fn ensure_correct_change_at_index(index: u32, asset_id: u256, asset_amount_to_spend: u64, contract_script_hash: u256, is_change_needed: bool) {
    let (asset_bits, available_asset_amount): (u256, u64) = get_input_explicit_asset_amount(index);
    assert!(jet::eq_256(unwrap(jet::input_script_hash(index)), contract_script_hash));
    assert!(jet::eq_32(jet::current_index(), index));
    
    match is_change_needed {
        true => {
            ensure_input_and_output_script_hash_eq(index);

            let (carry, collateral_change): (bool, u64) = jet::subtract_64(available_asset_amount, asset_amount_to_spend);
            ensure_zero_bit(carry);
            ensure_output_asset_with_amount_eq(index, asset_id, collateral_change);
        },
        false => assert!(jet::eq_64(asset_amount_to_spend, available_asset_amount)),
    }
}

/*
 * Funding Path
 */
fn funding_path(expected_asset_amount: u64) {
    assert!(jet::eq_32(jet::num_inputs(), 3));
    assert!(jet::eq_32(jet::num_outputs(), 7));

    ensure_input_and_output_script_hash_eq(0);
    ensure_input_and_output_script_hash_eq(1);
    assert!(dbg!(jet::eq_256(get_output_script_hash(0), get_output_script_hash(1))));

    assert!(jet::le_32(jet::current_index(), 1));

    ensure_output_script_hash_eq(2, get_output_script_hash(0));

    let (collateral_asset_bits, collateral_amount): (u256, u64) = get_output_explicit_asset_amount(2);
    let option_token_amount: u64 = unwrap_right::<(u1, u256)>(unwrap(unwrap(jet::issuance_asset_amount(0))));
    let grantor_token_amount: u64 = unwrap_right::<(u1, u256)>(unwrap(unwrap(jet::issuance_asset_amount(1))));
    assert!(jet::eq_64(option_token_amount, grantor_token_amount));

    divmod_eq(collateral_amount, param::COLLATERAL_PER_CONTRACT, option_token_amount);
    divmod_eq(expected_asset_amount, param::SETTLEMENT_PER_CONTRACT, option_token_amount);

    ensure_output_asset_with_amount_eq(2, param::COLLATERAL_ASSET_ID, collateral_amount);
    ensure_output_asset_with_amount_eq(3, param::OPTION_TOKEN_ASSET, option_token_amount);
    ensure_output_asset_with_amount_eq(4, param::GRANTOR_TOKEN_ASSET, grantor_token_amount);

    ensure_input_asset_eq(2, param::COLLATERAL_ASSET_ID);

    ensure_output_asset_eq(5, param::COLLATERAL_ASSET_ID);
    ensure_output_asset_eq(6, param::COLLATERAL_ASSET_ID);
}

/*
 * Cancellation Path
 */
fn cancellation_path(amount_to_burn: u64, collateral_amount_to_withdraw: u64, is_change_needed: bool) {
    let collateral_input_index: u32 = 0;
    let option_input_index: u32 = 1;
    let grantor_input_index: u32 = 2;

    let (burn_option_output_index, burn_grantor_output_index): (u32, u32) = match is_change_needed {
        true => (1, 2),
        false => (0, 1),
    };
    
    let expected_current_script_hash: u256 = get_input_script_hash(collateral_input_index);

    // Check and ensure collateral change
    ensure_correct_change_at_index(0, param::COLLATERAL_ASSET_ID, collateral_amount_to_withdraw, expected_current_script_hash, is_change_needed);

    // Burn option and grantor tokens
    ensure_output_is_op_return(burn_option_output_index);
    ensure_output_is_op_return(burn_grantor_output_index);

    ensure_output_asset_with_amount_eq(burn_option_output_index, param::OPTION_TOKEN_ASSET, amount_to_burn);
    ensure_output_asset_with_amount_eq(burn_grantor_output_index, param::GRANTOR_TOKEN_ASSET, amount_to_burn);

    // Ensure returned collateral amount is correct
    divmod_eq(collateral_amount_to_withdraw, param::COLLATERAL_PER_CONTRACT, amount_to_burn);
}

/*
 * Exercise Path
 */
fn exercise_path(option_amount_to_burn: u64, collateral_amount_to_get: u64, asset_amount_to_pay: u64, is_change_needed: bool) {
    jet::check_lock_time(param::START_TIME);

    let collateral_input_index: u32 = 0;

    let (burn_option_output_index, asset_to_covenant_output_index): (u32, u32) = match is_change_needed {
        true => (1, 2),
        false => (0, 1),
    };

    let expected_current_script_hash: u256 = get_input_script_hash(collateral_input_index);

    // Check and ensure collateral change
    ensure_correct_change_at_index(0, param::COLLATERAL_ASSET_ID, collateral_amount_to_get, expected_current_script_hash, is_change_needed);

    // Ensure collateral and asset amounts are correct
    divmod_eq(collateral_amount_to_get, param::COLLATERAL_PER_CONTRACT, option_amount_to_burn);
    divmod_eq(asset_amount_to_pay, param::SETTLEMENT_PER_CONTRACT, option_amount_to_burn);

    // Burn option token
    ensure_output_is_op_return(burn_option_output_index);
    ensure_output_asset_with_amount_eq(burn_option_output_index, param::OPTION_TOKEN_ASSET, option_amount_to_burn);

    // Ensure settlement asset and script hash are correct
    ensure_output_asset_with_amount_eq(asset_to_covenant_output_index, param::SETTLEMENT_ASSET_ID, asset_amount_to_pay);
    ensure_output_script_hash_eq(asset_to_covenant_output_index, expected_current_script_hash);
}

/*
 * Settlement Path
 */
fn settlement_path(grantor_token_amount_to_burn: u64, asset_amount: u64, is_change_needed: bool) {
    jet::check_lock_time(param::START_TIME);

    let target_asset_input_index: u32 = 0;

    let burn_grantor_output_index: u32 = match is_change_needed {
        true => 1,
        false => 0,
    };

    let expected_current_script_hash: u256 = get_input_script_hash(target_asset_input_index);

    // Check and ensure settlement asset change
    ensure_correct_change_at_index(0, param::SETTLEMENT_ASSET_ID, asset_amount, expected_current_script_hash, is_change_needed);
    
    // Ensure settlement asset and grantor token amounts are correct
    divmod_eq(asset_amount, param::SETTLEMENT_PER_CONTRACT, grantor_token_amount_to_burn);

    // Burn grantor token
    ensure_output_is_op_return(burn_grantor_output_index);
    ensure_output_asset_with_amount_eq(burn_grantor_output_index, param::GRANTOR_TOKEN_ASSET, grantor_token_amount_to_burn);
}

/*
 * Expiry Path
 */
fn expiry_path(grantor_token_amount_to_burn: u64, collateral_amount: u64, is_change_needed: bool) {
    jet::check_lock_time(param::EXPIRY_TIME);

    let collateral_input_index: u32 = 0;

    let burn_grantor_output_index: u32 = match is_change_needed {
        true => 1,
        false => 0,
    };

    let expected_current_script_hash: u256 = get_input_script_hash(collateral_input_index);

    // Check and ensure collateral change
    ensure_correct_change_at_index(0, param::COLLATERAL_ASSET_ID, collateral_amount, expected_current_script_hash, is_change_needed);

    // Ensure collateral amount is correct
    divmod_eq(collateral_amount, param::COLLATERAL_PER_CONTRACT, grantor_token_amount_to_burn);

    // Burn grantor token
    ensure_output_is_op_return(burn_grantor_output_index);
    ensure_output_asset_with_amount_eq(burn_grantor_output_index, param::GRANTOR_TOKEN_ASSET, grantor_token_amount_to_burn);
}

fn main() {
    match witness::PATH {
        Left(left_or_right: Either<u64, Either<(bool, u64, u64, u64), (bool, u64, u64)>>) => match left_or_right {
            Left(expected_asset_amount: u64) => {
                funding_path(expected_asset_amount)
            },
            Right(exercise_or_settlement: Either<(bool, u64, u64, u64), (bool, u64, u64)>) => match exercise_or_settlement {
                Left(params: (bool, u64, u64, u64)) => {
                    let (is_change_needed, amount_to_burn, collateral_amount, asset_amount): (bool, u64, u64, u64) = dbg!(params);
                    exercise_path(amount_to_burn, collateral_amount, asset_amount, is_change_needed)
                },
                Right(params: (bool, u64, u64)) => {
                    let (is_change_needed, amount_to_burn, asset_amount): (bool, u64, u64) = dbg!(params);
                    settlement_path(amount_to_burn, asset_amount, is_change_needed)
                },
            },
        },
        Right(left_or_right: Either<(bool, u64, u64), (bool, u64, u64)>) => match left_or_right {
            Left(params: (bool, u64, u64)) => {
                let (is_change_needed, grantor_token_amount_to_burn, collateral_amount): (bool, u64, u64) = params;
                expiry_path(grantor_token_amount_to_burn, collateral_amount, is_change_needed)
            },
            Right(params: (bool, u64, u64)) => {
                let (is_change_needed, amount_to_burn, collateral_amount): (bool, u64, u64) = params;
                cancellation_path(amount_to_burn, collateral_amount, is_change_needed)
            },
        },
    }
}
