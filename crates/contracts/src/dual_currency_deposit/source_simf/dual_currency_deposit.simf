/*
 * DCD: Dual Currency Deposit â€“ price-attested settlement and funding windows
 *
 * Flows implemented:
 *  - Maker funding: deposit settlement asset and collateral, issue grantor tokens
 *  - Taker funding: deposit collateral in window and receive filler tokens
 *  - Settlement: at SETTLEMENT_HEIGHT, oracle Schnorr signature over (height, price)
 *    selects LBTC vs ALT branch based on price <= STRIKE_PRICE
 *  - Early/post-expiry termination: taker returns filler; maker burns grantor tokens
 *  - Merge: consolidate 2/3/4 token UTXOs
 *
 * All amounts and asset/script invariants are enforced on-chain; time guards use
 * fallback locktime and height checks.
 *
 * Batching discussion: https://github.com/BlockstreamResearch/simplicity-contracts/issues/4
 */

// Verify Schnorr signature against SHA256 of (u32 || u64)
fn checksig_priceblock(pk: Pubkey, current_block_height: u32, price_at_current_block_height: u64, sig: Signature) {
    let hasher: Ctx8 = jet::sha_256_ctx_8_init();
    let hasher: Ctx8 = jet::sha_256_ctx_8_add_4(hasher, current_block_height);
    let hasher: Ctx8 = jet::sha_256_ctx_8_add_8(hasher, price_at_current_block_height);
    let msg: u256 = jet::sha_256_ctx_8_finalize(hasher);
    jet::bip_0340_verify((pk, msg), sig);
}

// Signed <= using XOR with 0x8000.. bias: a<=b (signed) iff (a^bias) <= (b^bias) (unsigned)
fn signed_le_u64(a_bits: u64, b_bits: u64) -> bool {
    let bias: u64 = 0x8000000000000000;
    jet::le_64(jet::xor_64(a_bits, bias), jet::xor_64(b_bits, bias))
}

fn signed_lt_u64(a: u64, b: u64) -> bool {
    let bias: u64 = 0x8000000000000000;
    jet::lt_64(jet::xor_64(a, bias), jet::xor_64(b, bias))
}

/// Assert: a == b * expected_q, via divmod
fn divmod_eq(a: u64, b: u64, expected_q: u64) {   
    let (q, r): (u64, u64) = jet::div_mod_64(a, b);
    assert!(jet::eq_64(q, expected_q));
    assert!(jet::eq_64(r, 0));
}

/// Assert: base_amount * basis_point_percentage == provided_amount * MAX_BASIS_POINTS
fn constraint_percentage(base_amount: u64, basis_point_percentage: u64, provided_amount: u64) {
    let MAX_BASIS_POINTS: u64 = 10000;

    let arg1: u256 = <(u128, u128)>::into((0, jet::multiply_64(base_amount, basis_point_percentage)));
    let arg2: u256 = <(u128, u128)>::into((0, jet::multiply_64(provided_amount, MAX_BASIS_POINTS)));

    assert!(jet::eq_256(arg1, arg2));
}

fn get_output_script_hash(index: u32) -> u256 {
    unwrap(jet::output_script_hash(index))
}

fn get_input_script_hash(index: u32) -> u256 {
    unwrap(jet::input_script_hash(index))
}

fn get_output_explicit_asset_amount(index: u32) -> (u256, u64) {
    let pair: (Asset1, Amount1) = unwrap(jet::output_amount(index));
    let (asset, amount): (Asset1, Amount1) = pair;
    let asset_bits: u256 = unwrap_right::<(u1, u256)>(asset);
    let amount: u64 = unwrap_right::<(u1, u256)>(amount);
    (asset_bits, amount)
}

fn get_input_explicit_asset_amount(index: u32) -> (u256, u64) {
    let pair: (Asset1, Amount1) = unwrap(jet::input_amount(index));
    let (asset, amount): (Asset1, Amount1) = pair;
    let asset_bits: u256 = unwrap_right::<(u1, u256)>(asset);
    let amount: u64 = unwrap_right::<(u1, u256)>(amount);
    (asset_bits, amount)
}

fn ensure_one_bit(bit: bool) { assert!(jet::eq_1(<bool>::into(bit), 1)); }
fn ensure_zero_bit(bit: bool) { assert!(jet::eq_1(<bool>::into(bit), 0)); }

fn ensure_one_bit_or(bit1: bool, bit2: bool) { 
    assert!(
        jet::eq_1(
            <u1>::into(jet::or_1(<bool>::into(bit1), <bool>::into(bit2))), 
            1
        )
    ); 
}

fn increment_by(index: u32, amount: u32) -> u32 {
    let (carry, result): (bool, u32) = jet::add_32(index, amount);
    ensure_zero_bit(carry);
    result
}

fn ensure_input_and_output_script_hash_eq(index: u32) {
    assert!(jet::eq_256(unwrap(jet::input_script_hash(index)), unwrap(jet::output_script_hash(index))));
}

fn ensure_output_is_op_return(index: u32) {
    match jet::output_null_datum(index, 0) {
        Some(entry: Option<Either<(u2, u256), Either<u1, u4>>>) => (),
        None => panic!(),
    }
}

fn ensure_input_asset_eq(index: u32, expected_bits: u256) {
    let asset: Asset1 = unwrap(jet::input_asset(index));
    let asset_bits: u256 = unwrap_right::<(u1, u256)>(asset);
    assert!(jet::eq_256(asset_bits, expected_bits));
}

fn ensure_output_asset_eq(index: u32, expected_bits: u256) {
    let asset: Asset1 = unwrap(jet::output_asset(index));
    let asset_bits: u256 = unwrap_right::<(u1, u256)>(asset);
    assert!(jet::eq_256(asset_bits, expected_bits));
}

fn ensure_output_asset_with_amount_eq(index: u32, expected_bits: u256, expected_amount: u64) {
    let (asset, amount): (u256, u64) = get_output_explicit_asset_amount(index);
    assert!(jet::eq_256(asset, expected_bits));
    assert!(jet::eq_64(amount, expected_amount));
}

fn ensure_input_script_hash_eq(index: u32, expected: u256) {
    assert!(jet::eq_256(unwrap(jet::input_script_hash(index)), expected));
}

fn ensure_output_script_hash_eq(index: u32, expected: u256) {
    assert!(jet::eq_256(unwrap(jet::output_script_hash(index)), expected));
}

fn ensure_correct_change_at_index(index: u32, asset_id: u256, asset_amount_to_spend: u64, contract_script_hash: u256, is_change_needed: bool) {
    let (asset_bits, available_asset_amount): (u256, u64) = get_input_explicit_asset_amount(index);
    assert!(jet::eq_256(unwrap(jet::input_script_hash(index)), contract_script_hash));
    assert!(jet::eq_32(jet::current_index(), index));
    
    match is_change_needed {
        true => {
            ensure_input_and_output_script_hash_eq(index);

            let (carry, collateral_change): (bool, u64) = jet::subtract_64(available_asset_amount, asset_amount_to_spend);
            ensure_zero_bit(carry);
            ensure_output_asset_with_amount_eq(index, asset_id, collateral_change);
        },
        false => assert!(jet::eq_64(asset_amount_to_spend, available_asset_amount)),
    }
}

fn merge_2_tokens() {
    // 2 tokens to merge + 1 input as fee
    assert!(jet::eq_32(jet::num_inputs(), 3));
    // 3 outputs: 1 merged token + 1 change + 1 fee
    assert!(jet::eq_32(jet::num_outputs(), 3));
    assert!(jet::le_32(jet::current_index(), 1));
    
    ensure_input_and_output_script_hash_eq(0);
    let script_hash: u256 = get_input_script_hash(0);
    assert!(jet::eq_256(script_hash, get_input_script_hash(1)));
}

fn merge_3_tokens() {
    // 3 tokens to merge + 1 input as fee
    assert!(jet::eq_32(jet::num_inputs(), 4));
    // 3 outputs: 1 merged token + 1 change + 1 fee
    assert!(jet::eq_32(jet::num_outputs(), 3));
    assert!(jet::le_32(jet::current_index(), 2));
    
    ensure_input_and_output_script_hash_eq(0);
    let script_hash: u256 = get_input_script_hash(0);
    assert!(jet::eq_256(script_hash, get_input_script_hash(1)));
    assert!(jet::eq_256(script_hash, get_input_script_hash(2)));
}

fn merge_4_tokens() {
    // 4 tokens to merge + 1 input as fee
    assert!(jet::eq_32(jet::num_inputs(), 5));
    // 3 outputs: 1 merged token + 1 change + 1 fee
    assert!(jet::eq_32(jet::num_outputs(), 3));
    assert!(jet::le_32(jet::current_index(), 3));
    
    ensure_input_and_output_script_hash_eq(0);
    let script_hash: u256 = get_input_script_hash(0);
    assert!(jet::eq_256(script_hash, get_input_script_hash(1)));
    assert!(jet::eq_256(script_hash, get_input_script_hash(2)));
    assert!(jet::eq_256(script_hash, get_input_script_hash(3)));
}

/*
* Maker funding path
* Params: 
*   1. FILLER_PER_SETTLEMENT_COLLATERAL
*   2. FILLER_PER_SETTLEMENT_ASSET
*   3. FILLER_PER_PRINCIPAL_COLLATERAL
*   4. GRANTOR_SETTLEMENT_PER_DEPOSITED_ASSET
*   5. GRANTOR_COLLATERAL_PER_DEPOSITED_COLLATERAL
*   6. GRANTOR_PER_SETTLEMENT_COLLATERAL
*   7. GRANTOR_PER_SETTLEMENT_ASSET
*/
fn maker_funding_path(principal_collateral_amount: u64, principal_asset_amount: u64, interest_collateral_amount: u64, interest_asset_amount: u64) {
    let current_time: u32 = <u32>::into(jet::lock_time());
    assert!(jet::lt_32(current_time, param::TAKER_FUNDING_START_TIME));

    ensure_input_and_output_script_hash_eq(0);
    ensure_input_and_output_script_hash_eq(1);
    ensure_input_and_output_script_hash_eq(2);

    assert!(jet::le_32(jet::current_index(), 2));
    
    let script_hash: u256 = get_output_script_hash(0);
    ensure_output_script_hash_eq(1, script_hash);
    ensure_output_script_hash_eq(2, script_hash);
    ensure_output_script_hash_eq(3, script_hash);
    ensure_output_script_hash_eq(4, script_hash);
    ensure_output_script_hash_eq(5, script_hash);

    let (collateral_asset_bits, collateral_amount): (u256, u64) = get_output_explicit_asset_amount(3);
    let (settlement_asset_bits, settlement_amount): (u256, u64) = get_output_explicit_asset_amount(4);
    let filler_token_amount: u64 = unwrap_right::<(u1, u256)>(unwrap(unwrap(jet::issuance_asset_amount(0))));
    let grantor_collateral_token_amount: u64 = unwrap_right::<(u1, u256)>(unwrap(unwrap(jet::issuance_asset_amount(1))));
    let grantor_settlement_token_amount: u64 = unwrap_right::<(u1, u256)>(unwrap(unwrap(jet::issuance_asset_amount(2))));
    assert!(jet::eq_64(filler_token_amount, grantor_collateral_token_amount));
    assert!(jet::eq_64(filler_token_amount, grantor_settlement_token_amount));

    divmod_eq(principal_asset_amount, param::STRIKE_PRICE, principal_collateral_amount);

    assert!(jet::eq_64(collateral_amount, interest_collateral_amount));
    constraint_percentage(principal_collateral_amount, param::INCENTIVE_BASIS_POINTS, collateral_amount);

    let MAX_BASIS_POINTS: u64 = 10000;
    let (carry, asset_incentive_percentage): (bool, u64) = jet::add_64(param::INCENTIVE_BASIS_POINTS, MAX_BASIS_POINTS);
    ensure_zero_bit(carry);

    constraint_percentage(principal_asset_amount, asset_incentive_percentage, settlement_amount);

    let (carry, calculated_total_asset_amount): (bool, u64) = jet::add_64(principal_asset_amount, interest_asset_amount);
    ensure_zero_bit(carry);
    assert!(jet::eq_64(calculated_total_asset_amount, settlement_amount));

    let (carry, calculated_total_collateral_amount): (bool, u64) = jet::add_64(principal_collateral_amount, interest_collateral_amount);
    ensure_zero_bit(carry);

    // Filler token constraints
    divmod_eq(calculated_total_collateral_amount, param::FILLER_PER_SETTLEMENT_COLLATERAL, filler_token_amount);
    divmod_eq(calculated_total_asset_amount, param::FILLER_PER_SETTLEMENT_ASSET, filler_token_amount);
    divmod_eq(principal_collateral_amount, param::FILLER_PER_PRINCIPAL_COLLATERAL, filler_token_amount);

    // Grantor token constraints
    divmod_eq(calculated_total_asset_amount, param::GRANTOR_SETTLEMENT_PER_DEPOSITED_ASSET, grantor_settlement_token_amount);
    divmod_eq(interest_collateral_amount, param::GRANTOR_COLLATERAL_PER_DEPOSITED_COLLATERAL, grantor_collateral_token_amount);

    divmod_eq(calculated_total_collateral_amount, param::GRANTOR_PER_SETTLEMENT_COLLATERAL, grantor_collateral_token_amount);
    // divmod_eq(calculated_total_collateral_amount, param::GRANTOR_PER_SETTLEMENT_COLLATERAL, grantor_settlement_token_amount); // duplicated because of lines 203-204

    divmod_eq(calculated_total_asset_amount, param::GRANTOR_PER_SETTLEMENT_ASSET, grantor_collateral_token_amount);
    // divmod_eq(calculated_total_asset_amount, param::GRANTOR_PER_SETTLEMENT_ASSET, grantor_settlement_token_amount); // duplicated because of lines 203-204

    assert!(jet::eq_256(param::COLLATERAL_ASSET_ID, collateral_asset_bits));
    assert!(jet::eq_256(param::SETTLEMENT_ASSET_ID, settlement_asset_bits));

    ensure_output_asset_with_amount_eq(5, param::FILLER_TOKEN_ASSET, filler_token_amount);
    ensure_output_asset_with_amount_eq(6, param::GRANTOR_COLLATERAL_TOKEN_ASSET, grantor_collateral_token_amount);
    ensure_output_asset_with_amount_eq(7, param::GRANTOR_SETTLEMENT_TOKEN_ASSET, grantor_settlement_token_amount);
}

fn taker_funding_path(collateral_amount_to_deposit: u64, filler_token_amount_to_get: u64, is_change_needed: bool) {
    let current_time: u32 = <u32>::into(jet::lock_time());
    assert!(jet::le_32(param::TAKER_FUNDING_START_TIME, current_time));
    assert!(jet::lt_32(current_time, param::TAKER_FUNDING_END_TIME));
    assert!(jet::lt_32(current_time, param::CONTRACT_EXPIRY_TIME));

    let filler_token_input_index: u32 = 0;
    let collateral_input_index: u32 = 1;

    let (collateral_to_covenant_output_index, filler_to_user_output_index): (u32, u32) = match is_change_needed {
        true => (1, 2),
        false => (0, 1),
    };

    let expected_current_script_hash: u256 = get_input_script_hash(filler_token_input_index);

    // Check and ensure filler token change
    ensure_correct_change_at_index(0, param::FILLER_TOKEN_ASSET, filler_token_amount_to_get, expected_current_script_hash, is_change_needed);

    // Ensure collateral and asset amounts are correct
    divmod_eq(collateral_amount_to_deposit, param::FILLER_PER_PRINCIPAL_COLLATERAL, filler_token_amount_to_get);
    
    // Ensure collateral asset and script hash are correct
    ensure_output_asset_with_amount_eq(collateral_to_covenant_output_index, param::COLLATERAL_ASSET_ID, collateral_amount_to_deposit);
    ensure_output_script_hash_eq(collateral_to_covenant_output_index, expected_current_script_hash);

    ensure_output_asset_with_amount_eq(filler_to_user_output_index, param::FILLER_TOKEN_ASSET, filler_token_amount_to_get);
}

fn taker_early_termination_path(filler_token_amount_to_return: u64, collateral_amount_to_get: u64, is_change_needed: bool) {
    let current_time: u32 = <u32>::into(jet::lock_time());
    ensure_one_bit_or(jet::le_32(current_time, param::EARLY_TERMINATION_END_TIME), jet::le_32(param::CONTRACT_EXPIRY_TIME, current_time));

    let collateral_input_index: u32 = 0;
    let filler_token_input_index: u32 = 1;

    let (return_filler_output_index, return_collateral_output_index): (u32, u32) = match is_change_needed {
        true => (1, 2),
        false => (0, 1),
    };

    let expected_current_script_hash: u256 = get_input_script_hash(collateral_input_index);
    
    // Check and ensure collateral change
    ensure_correct_change_at_index(0, param::COLLATERAL_ASSET_ID, collateral_amount_to_get, expected_current_script_hash, is_change_needed);

    // Ensure collateral and asset amounts are correct
    divmod_eq(collateral_amount_to_get, param::FILLER_PER_PRINCIPAL_COLLATERAL, filler_token_amount_to_return);
    
    // Ensure filler token transferred to covenant
    ensure_output_asset_with_amount_eq(return_filler_output_index, param::FILLER_TOKEN_ASSET, filler_token_amount_to_return);
    ensure_output_script_hash_eq(return_filler_output_index, expected_current_script_hash);

    // Ensure collateral transferred to user
    ensure_output_asset_with_amount_eq(return_collateral_output_index, param::COLLATERAL_ASSET_ID, collateral_amount_to_get);
}

fn maker_collateral_termination_path(grantor_collateral_amount_to_burn: u64, collateral_amount_to_get: u64, is_change_needed: bool) {
    let current_time: u32 = <u32>::into(jet::lock_time());
    ensure_one_bit_or(jet::le_32(current_time, param::EARLY_TERMINATION_END_TIME), jet::le_32(param::CONTRACT_EXPIRY_TIME, current_time));

    let collateral_input_index: u32 = 0;
    let grantor_collateral_token_input_index: u32 = 1;

    let (burn_grantor_collateral_output_index, return_collateral_output_index): (u32, u32) = match is_change_needed {
        true => (1, 2),
        false => (0, 1),
    };

    let expected_current_script_hash: u256 = get_input_script_hash(collateral_input_index);
    
    // Check and ensure collateral change
    ensure_correct_change_at_index(0, param::COLLATERAL_ASSET_ID, collateral_amount_to_get, expected_current_script_hash, is_change_needed);

    // Ensure collateral and asset amounts are correct
    divmod_eq(collateral_amount_to_get, param::GRANTOR_COLLATERAL_PER_DEPOSITED_COLLATERAL, grantor_collateral_amount_to_burn);
    
    // Burn grantor collateral token
    ensure_output_is_op_return(burn_grantor_collateral_output_index);
    ensure_output_asset_with_amount_eq(burn_grantor_collateral_output_index, param::GRANTOR_COLLATERAL_TOKEN_ASSET, grantor_collateral_amount_to_burn);

    // Ensure collateral transferred to user
    ensure_output_asset_with_amount_eq(return_collateral_output_index, param::COLLATERAL_ASSET_ID, collateral_amount_to_get);
}

fn maker_settlement_termination_path(grantor_settlement_amount_to_burn: u64, settlement_amount_to_get: u64, is_change_needed: bool) {
    let current_time: u32 = <u32>::into(jet::lock_time());
    ensure_one_bit_or(jet::le_32(current_time, param::EARLY_TERMINATION_END_TIME), jet::le_32(param::CONTRACT_EXPIRY_TIME, current_time));

    let settlement_asset_input_index: u32 = 0;
    let grantor_settlement_token_input_index: u32 = 1;

    let (burn_grantor_settlement_output_index, return_settlement_output_index): (u32, u32) = match is_change_needed {
        true => (1, 2),
        false => (0, 1),
    };

    let expected_current_script_hash: u256 = get_input_script_hash(settlement_asset_input_index);
    
    // Check and ensure settlement asset change
    ensure_correct_change_at_index(0, param::SETTLEMENT_ASSET_ID, settlement_amount_to_get, expected_current_script_hash, is_change_needed);

    // Ensure settlement asset amount is correct
    divmod_eq(settlement_amount_to_get, param::GRANTOR_SETTLEMENT_PER_DEPOSITED_ASSET, grantor_settlement_amount_to_burn);
    
    // Burn grantor settlement token
    ensure_output_is_op_return(burn_grantor_settlement_output_index);
    ensure_output_asset_with_amount_eq(burn_grantor_settlement_output_index, param::GRANTOR_SETTLEMENT_TOKEN_ASSET, grantor_settlement_amount_to_burn);

    // Ensure settlement asset transferred to user
    ensure_output_asset_with_amount_eq(return_settlement_output_index, param::SETTLEMENT_ASSET_ID, settlement_amount_to_get);
}

fn ensure_correct_return_at(user_output_index: u32, asset_id: u256, amount_to_get: u64, fee_basis_points: u64) {
    match jet::eq_64(fee_basis_points, 0) {
        true => ensure_output_asset_with_amount_eq(user_output_index, asset_id, amount_to_get),
        false => {
            let fee_output_index: u32 = increment_by(user_output_index, 1);

            let (user_asset_bits, user_amount): (u256, u64) = get_output_explicit_asset_amount(user_output_index);
            assert!(jet::eq_256(user_asset_bits, asset_id));

            let (fee_asset_bits, fee_amount): (u256, u64) = get_output_explicit_asset_amount(fee_output_index);
            assert!(jet::eq_256(fee_asset_bits, asset_id));

            let (carry, calculated_total_amount): (bool, u64) = jet::add_64(user_amount, fee_amount);
            ensure_zero_bit(carry);

            constraint_percentage(calculated_total_amount, fee_basis_points, fee_amount);

            ensure_output_script_hash_eq(fee_output_index, param::FEE_SCRIPT_HASH);
        },
    };
}

fn maker_settlement_path(price_at_current_block_height: u64, oracle_sig: Signature, grantor_amount_to_burn: u64, amount_to_get: u64, is_change_needed: bool) {
    jet::check_lock_height(param::SETTLEMENT_HEIGHT);
    checksig_priceblock(param::ORACLE_PK, param::SETTLEMENT_HEIGHT, price_at_current_block_height, oracle_sig);

    match jet::le_64(price_at_current_block_height, param::STRIKE_PRICE) {
        true => {
            // Maker gets ALT
            let settlement_asset_input_index: u32 = 0;

            let (burn_grantor_settlement_output_index, burn_grantor_collateral_output_index, settlement_output_index): (u32, u32, u32) = match is_change_needed {
                true => (1, 2, 3),
                false => (0, 1, 2),
            };

            let expected_current_script_hash: u256 = get_input_script_hash(settlement_asset_input_index);
            
            // Check and ensure settlement asset change
            ensure_correct_change_at_index(0, param::SETTLEMENT_ASSET_ID, amount_to_get, expected_current_script_hash, is_change_needed);

            // Ensure settlement asset amount is correct
            divmod_eq(amount_to_get, param::GRANTOR_PER_SETTLEMENT_ASSET, grantor_amount_to_burn);
            
            // Burn grantor settlement and collateral tokens
            ensure_output_is_op_return(burn_grantor_settlement_output_index);
            ensure_output_asset_with_amount_eq(burn_grantor_settlement_output_index, param::GRANTOR_SETTLEMENT_TOKEN_ASSET, grantor_amount_to_burn);
            ensure_output_is_op_return(burn_grantor_collateral_output_index);
            ensure_output_asset_with_amount_eq(burn_grantor_collateral_output_index, param::GRANTOR_COLLATERAL_TOKEN_ASSET, grantor_amount_to_burn);

            // Ensure settlement asset transferred to user
            ensure_correct_return_at(settlement_output_index, param::SETTLEMENT_ASSET_ID, amount_to_get, param::FEE_BASIS_POINTS);
        },
        false => {
            // Maker gets the LBTC
            let collateral_input_index: u32 = 0;

            let (burn_grantor_collateral_output_index, burn_grantor_settlement_output_index, collateral_output_index): (u32, u32, u32) = match is_change_needed {
                true => (1, 2, 3),
                false => (0, 1, 2),
            };

            let expected_current_script_hash: u256 = get_input_script_hash(collateral_input_index);
            
            // Check and ensure collateral change
            ensure_correct_change_at_index(0, param::COLLATERAL_ASSET_ID, amount_to_get, expected_current_script_hash, is_change_needed);

            // Ensure collateral and asset amounts are correct
            divmod_eq(amount_to_get, param::GRANTOR_PER_SETTLEMENT_COLLATERAL, grantor_amount_to_burn);
            
            // Burn grantor collateral and settlement tokens
            ensure_output_is_op_return(burn_grantor_collateral_output_index);
            ensure_output_asset_with_amount_eq(burn_grantor_collateral_output_index, param::GRANTOR_COLLATERAL_TOKEN_ASSET, grantor_amount_to_burn);
            ensure_output_is_op_return(burn_grantor_settlement_output_index);
            ensure_output_asset_with_amount_eq(burn_grantor_settlement_output_index, param::GRANTOR_SETTLEMENT_TOKEN_ASSET, grantor_amount_to_burn);

            // Ensure collateral transferred to user
            ensure_correct_return_at(collateral_output_index, param::COLLATERAL_ASSET_ID, amount_to_get, param::FEE_BASIS_POINTS);
        },
    }
}

fn taker_settlement_path(price_at_current_block_height: u64, oracle_sig: Signature, filler_amount_to_burn: u64, amount_to_get: u64, is_change_needed: bool) {
    jet::check_lock_height(param::SETTLEMENT_HEIGHT);
    checksig_priceblock(param::ORACLE_PK, param::SETTLEMENT_HEIGHT, price_at_current_block_height, oracle_sig);

    match jet::le_64(price_at_current_block_height, param::STRIKE_PRICE) {
        true => {
            // Taker receives LBTC principal+interest
            let collateral_input_index: u32 = 0;

            let (burn_filler_output_index, collateral_output_index): (u32, u32) = match is_change_needed {
                true => (1, 2),
                false => (0, 1),
            };

            let expected_current_script_hash: u256 = get_input_script_hash(collateral_input_index);
            
            // Check and ensure collateral change
            ensure_correct_change_at_index(0, param::COLLATERAL_ASSET_ID, amount_to_get, expected_current_script_hash, is_change_needed);

            // Ensure collateral and asset amounts are correct
            divmod_eq(amount_to_get, param::FILLER_PER_SETTLEMENT_COLLATERAL, filler_amount_to_burn);
            
            // Burn filler token
            ensure_output_is_op_return(burn_filler_output_index);
            ensure_output_asset_with_amount_eq(burn_filler_output_index, param::FILLER_TOKEN_ASSET, filler_amount_to_burn);

            // Ensure collateral transferred to user
            ensure_correct_return_at(collateral_output_index, param::COLLATERAL_ASSET_ID, amount_to_get, param::FEE_BASIS_POINTS);
        },
        false => {
            // Taker receives ALT
            let settlement_asset_input_index: u32 = 0;

            let (burn_filler_output_index, settlement_output_index): (u32, u32) = match is_change_needed {
                true => (1, 2),
                false => (0, 1),
            };

            let expected_current_script_hash: u256 = get_input_script_hash(settlement_asset_input_index);
            
            // Check and ensure settlement asset change
            ensure_correct_change_at_index(0, param::SETTLEMENT_ASSET_ID, amount_to_get, expected_current_script_hash, is_change_needed);

            // Ensure settlement asset amount is correct
            divmod_eq(amount_to_get, param::FILLER_PER_SETTLEMENT_ASSET, filler_amount_to_burn);
            
            // Burn filler token
            ensure_output_is_op_return(burn_filler_output_index);
            ensure_output_asset_with_amount_eq(burn_filler_output_index, param::FILLER_TOKEN_ASSET, filler_amount_to_burn);

            // Ensure filler token transferred to user
            ensure_correct_return_at(settlement_output_index, param::SETTLEMENT_ASSET_ID, amount_to_get, param::FEE_BASIS_POINTS);
        },
    }
}

fn main() {
    let token_branch: Either<(), ()> = witness::TOKEN_BRANCH;
    let merge_branch: Either<Either<(), ()>, ()> = witness::MERGE_BRANCH;

    match witness::PATH {
        Left(funding_or_settlement: Either<Either<(u64, u64, u64, u64), (u64, u64, bool)>, (u64, Signature, u64, u64, bool)>) => match funding_or_settlement {
            // Funding branches
            Left(funding_params: Either<(u64, u64, u64, u64), (u64, u64, bool)>) => match funding_params {
                // Maker funding: (principal_collateral_amount, principal_asset_amount, interest_collateral_amount, interest_asset_amount)
                Left(params: (u64, u64, u64, u64)) => {
                    let (principal_collateral_amount, principal_asset_amount, interest_collateral_amount, interest_asset_amount): (u64, u64, u64, u64) = params;
                    maker_funding_path(principal_collateral_amount, principal_asset_amount, interest_collateral_amount, interest_asset_amount)
                },
                // Taker funding: (collateral_amount_to_deposit, filler_token_amount_to_get, is_change_needed)
                Right(params: (u64, u64, bool)) => {
                    let (collateral_amount_to_deposit, filler_token_amount_to_get, is_change_needed): (u64, u64, bool) = params;
                    taker_funding_path(collateral_amount_to_deposit, filler_token_amount_to_get, is_change_needed)
                },
            },
            // Settlement branches (oracle price attested)
            Right(params: (u64, Signature, u64, u64, bool)) => {
                let (price_at_current_block_height, oracle_sig, amount_to_burn, amount_to_get, is_change_needed): (u64, Signature, u64, u64, bool) = params;

                match token_branch {
                    // Maker settlement: burn grantor token
                    Left(u: ()) => maker_settlement_path(price_at_current_block_height, oracle_sig, amount_to_burn, amount_to_get, is_change_needed),
                    // Taker settlement: burn filler token
                    Right(u: ()) => taker_settlement_path(price_at_current_block_height, oracle_sig, amount_to_burn, amount_to_get, is_change_needed),
                }
            },
        },
        // Termination flows (early termination or post-expiry) or Merge flows
        Right(termination_or_maker_or_merge: Either<Either<(bool, u64, u64), (bool, u64, u64)>, ()>) => match termination_or_maker_or_merge {
            Left(termination_or_maker: Either<(bool, u64, u64), (bool, u64, u64)>) => match termination_or_maker {
                // Taker early termination: (is_change_needed, filler_token_amount_to_return, collateral_amount_to_get)
                Left(params: (bool, u64, u64)) => {
                    let (is_change_needed, filler_token_amount_to_return, collateral_amount_to_get): (bool, u64, u64) = params;
                    taker_early_termination_path(filler_token_amount_to_return, collateral_amount_to_get, is_change_needed)
                },
                // Maker termination (burn grantor token): choose collateral vs settlement token via token_branch
                Right(params: (bool, u64, u64)) => {
                    let (is_change_needed, grantor_token_amount_to_burn, amount_to_get): (bool, u64, u64) = params;

                    match token_branch {
                        // Burn grantor collateral token -> receive collateral
                        Left(u: ()) => maker_collateral_termination_path(grantor_token_amount_to_burn, amount_to_get, is_change_needed),
                        // Burn grantor settlement token -> receive settlement asset
                        Right(u: ()) => maker_settlement_termination_path(grantor_token_amount_to_burn, amount_to_get, is_change_needed),
                    }
                },
            },
            Right(u: ()) => {
                // Merge tokens based on MERGE_BRANCH discriminator
                match merge_branch {
                    Left(left_or_right: Either<(), ()>) => match left_or_right {
                        Left(u: ()) => merge_2_tokens(),
                        Right(u: ()) => merge_3_tokens(),
                    },
                    Right(u: ()) => merge_4_tokens(),
                }
            },
        },
    }

}
